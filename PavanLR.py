# -*- coding: utf-8 -*-
"""STREAMLIT LSTM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eoN80OO2qR9Eyhovyf9Kc39c7xjxeHiS
"""

# streamlit_arima_kpss.py
import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

from statsmodels.tsa.stattools import kpss
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import statsmodels.api as sm
from sklearn.preprocessing import PolynomialFeatures

# ---- Streamlit page setup ----
st.set_page_config(page_title="ARIMA with KPSS & Trend Handling", layout="wide")
st.title("ARIMA workflow with KPSS → differencing or detrending")
st.markdown("""
- Runs KPSS to decide trend-stationary vs difference-stationary.
- If trend-stationary: finds best polynomial degree (1..9 by AIC) and detrends.
- If difference-stationary: differences the series.
- Then you can select ARIMA(p,d,q) via sliders and fit the model to the processed series.
- Shows ACF / PACF and model diagnostics.
""")

# ---- Sidebar inputs ----
st.sidebar.header("Settings")
ticker = st.sidebar.text_input("Stock Ticker", "AAPL").upper()
days = st.sidebar.slider("Days to download", 60, 2000, 365)
start_date = (datetime.now() - timedelta(days=days)).date().isoformat()
end_date = datetime.now().date().isoformat()
st.sidebar.markdown(f"Date range: **{start_date} → {end_date}**")

p = st.sidebar.slider("p (AR order)", 0, 5, 1)
d = st.sidebar.slider("d (diff order)", 0, 2, 0)
q = st.sidebar.slider("q (MA order)", 0, 5, 1)
max_poly_degree = 9
run_btn = st.sidebar.button("Run KPSS & Prepare Series")
fit_arima_btn = st.sidebar.button("Fit ARIMA(p,d,q)")

# Debugging option
show_debug = st.sidebar.checkbox("Show debug info (AICs, poly powers, etc.)", value=False)

# Helper functions
def run_kpss(series, regression='ct', nlags='auto'):
    """Run KPSS and return (stat, pvalue, lags, crit_vals). Wrap errors."""
    try:
        stat, p_value, lags, crit = kpss(series, regression=regression, nlags=nlags)
        return {"stat": stat, "pvalue": p_value, "lags": lags, "crit": crit, "error": None}
    except Exception as e:
        return {"stat": None, "pvalue": None, "lags": None, "crit": None, "error": str(e)}

def best_polynomial_detrend(y, X_scaled, max_deg=9):
    """Fit OLS for polynomial degrees 1..max_deg (use include constant). Select degree by lowest AIC.
    X_scaled should be a 1D array (centered & scaled ordinal dates). Returns best_deg, trend_fit, residuals, debug_list."""
    best_aic = np.inf
    best_deg = 1
    best_fit = None
    results = []
    for deg in range(1, max_deg+1):
        poly = PolynomialFeatures(degree=deg, include_bias=True)  # includes constant term
        X_poly = poly.fit_transform(X_scaled.reshape(-1, 1))  # shape (n, deg+1)
        try:
            model = sm.OLS(y, X_poly).fit()
            aic = model.aic
            results.append((deg, aic))
            if aic < best_aic:
                best_aic = aic
                best_deg = deg
                best_fit = model
        except Exception as e:
            results.append((deg, np.nan))
    if best_fit is None:
        raise RuntimeError("Failed to fit polynomial trends for any degree.")
    trend_vals = best_fit.predict(poly.transform(X_scaled.reshape(-1, 1)))
    residuals = y - trend_vals
    return best_deg, trend_vals, residuals, results, poly, best_fit

# Container for processed series
processed = {
    "original_series": None,
    "processed_series": None,
    "mode": None,  # 'trend_stationary' or 'difference_stationary' or 'nonstationary'
    "trend_degree": None,
    "trend_vals": None,
    "diffed_times": 0
}

# ---- Step 1: Download data and run KPSS ----
if run_btn:
    st.header(f"Preparing series for {ticker}")
    try:
        with st.spinner("Downloading data from Yahoo Finance..."):
            df = yf.download(ticker, period=f"{days}d", progress=False)
        if df is None or df.empty or "High" not in df.columns:
            st.error("No data found or 'High' column missing. Try another ticker or date range.")
        else:
            series = df["High"].dropna()
            st.success(f"Downloaded {len(series)} data points ({series.index[0].date()} → {series.index[-1].date()})")
            st.write("Preview:")
            st.dataframe(series.tail(10).to_frame("High"))

            # store original
            processed["original_series"] = series.copy()

            # KPSS for trend-stationary (regression='ct')
            st.subheader("KPSS test for trend-stationarity (regression='ct')")
            kpss_trend = run_kpss(series.values, regression='ct')
            if kpss_trend["error"]:
                st.error(f"KPSS (trend) error: {kpss_trend['error']}")
            else:
                st.write(f"KPSS stat = {kpss_trend['stat']:.4f}, p-value = {kpss_trend['pvalue']:.4f}")
                st.write("Critical values:", kpss_trend["crit"])

            # Decision logic:
            # If p > 0.05 for regression='ct' => fail to reject trend-stationary (i.e., trend stationary)
            if kpss_trend["pvalue"] is not None and kpss_trend["pvalue"] > 0.05:
                st.info("Series appears to be TREND-STATIONARY (KPSS regression='ct' p > 0.05). We'll detrend.")
                # Detrend by fitting best polynomial degree 1..9 using OLS AIC
                dates_ord = np.array([d.toordinal() for d in series.index], dtype=float)
                dates_mean = dates_ord.mean()
                dates_range = dates_ord.max() - dates_ord.min()
                if dates_range == 0:
                    st.error("All dates identical — cannot detrend.")
                else:
                    X_scaled = (dates_ord - dates_mean) / dates_range  # centered & scaled
                    y = series.values.astype(float)
                    try:
                        best_deg, trend_vals, residuals, results, poly_obj, best_fit_model = best_polynomial_detrend(
                            y, X_scaled, max_deg=max_poly_degree
                        )
                        processed["processed_series"] = pd.Series(residuals, index=series.index)
                        processed["mode"] = "trend_stationary"
                        processed["trend_degree"] = best_deg
                        processed["trend_vals"] = pd.Series(trend_vals, index=series.index)
                        st.success(f"Detrended with polynomial degree = {best_deg} (selected by lowest AIC).")
                        if show_debug:
                            st.write("AIC by degree (degree, AIC):")
                            st.write(results)
                            st.write("Selected model summary (OLS):")
                            st.text(best_fit_model.summary().as_text())
                    except Exception as e:
                        st.error(f"Detrending failed: {e}")
                        processed["mode"] = "nonstationary"
                        processed["processed_series"] = series.copy()
            else:
                st.info("Series is NOT trend-stationary (KPSS regression='ct' p <= 0.05). We'll check differencing.")
                # Check difference-stationary: test KPSS on first difference (regression='c')
                diff1 = series.diff().dropna()
                if len(diff1) < 10:
                    st.warning("Too few points after differencing to confidently test stationarity.")
                kpss_diff = run_kpss(diff1.values, regression='c')
                if kpss_diff["error"]:
                    st.error(f"KPSS (diff) error: {kpss_diff['error']}")
                else:
                    st.write(f"KPSS on first difference stat = {kpss_diff['stat']:.4f}, p-value = {kpss_diff['pvalue']:.4f}")
                    st.write("Critical values:", kpss_diff["crit"])
                # If p > 0.05 on diff -> difference-stationary
                if kpss_diff["pvalue"] is not None and kpss_diff["pvalue"] > 0.05:
                    st.success("Series appears to be DIFFERENCE-STATIONARY (first difference is stationary). We'll difference once.")
                    processed["processed_series"] = diff1.copy()
                    processed["mode"] = "difference_stationary"
                    processed["diffed_times"] = 1
                else:
                    st.warning("Even after first differencing the series may not be stationary. You can still fit ARIMA with manual d.")
                    processed["processed_series"] = series.copy()
                    processed["mode"] = "nonstationary"

            # Show what we will fit
            st.subheader("Series that will be used to fit ARIMA (processed series)")
            st.write(f"Mode = {processed['mode']}")
            st.line_chart(processed["processed_series"].rename("processed_series"))

            # Show ACF / PACF of processed series (not yet differenced by user-specified d)
            st.subheader("ACF & PACF (processed series)")
            fig_acf = plt.figure(figsize=(10, 3))
            plot_acf(processed["processed_series"].dropna(), lags=40, zero=False, ax=fig_acf.add_subplot(1, 2, 1))
            plot_pacf(processed["processed_series"].dropna(), lags=40, zero=False, ax=fig_acf.add_subplot(1, 2, 2), method='ywm')
            st.pyplot(fig_acf)

    except Exception as e:
        st.error(f"Failed pipeline: {e}")

# ---- Step 2: Fit ARIMA on processed series using user-selected (p,d,q) ----
if fit_arima_btn:
    st.header(f"Fitting ARIMA({p},{d},{q}) for {ticker}")
    if processed["processed_series"] is None:
        st.error("No processed series available. First click 'Run KPSS & Prepare Series'.")
    else:
        try:
            series_to_use = processed["processed_series"].dropna().astype(float)
            # If user wants to apply additional differencing (d slider), apply it here to the series used for model-building
            # Note: ARIMA(d) will also difference internally, but many users like to visualize ACF/PACF of the series they think is stationary.
            if d > 0:
                series_for_plots = series_to_use.diff(d).dropna()
            else:
                series_for_plots = series_to_use

            if len(series_for_plots) < 10:
                st.warning("After differencing, too few data points remain; model fit may fail or be unreliable.")

            # Show ACF/PACF of series that ARIMA will see (post-user-d differencing)
            st.subheader("ACF & PACF of series (after applying user 'd' differencing for visualization)")
            fig2 = plt.figure(figsize=(10, 3))
            plot_acf(series_for_plots, lags=40, zero=False, ax=fig2.add_subplot(1, 2, 1))
            plot_pacf(series_for_plots, lags=40, zero=False, ax=fig2.add_subplot(1, 2, 2), method='ywm')
            st.pyplot(fig2)

            # Fit ARIMA - note: statsmodels' ARIMA takes the original series and internal diff order d parameter; here we pass the processed series
            st.write("Fitting ARIMA model (this may take a few seconds)...")
            with st.spinner("Fitting ARIMA..."):
                # Statsmodels ARIMA expects a 1D array like series_to_use
                model = ARIMA(series_to_use, order=(p, d, q), enforce_stationarity=False, enforce_invertibility=False)
                fitted = model.fit()

            st.success("ARIMA fitted.")
            st.subheader("ARIMA Summary")
            st.text(fitted.summary().as_text())

            # Residuals diagnostics
            resids = fitted.resid
            st.subheader("Residual diagnostics (from fitted ARIMA)")
            st.write("Residual mean:", np.mean(resids))
            st.write("Residual std:", np.std(resids))
            st.line_chart(resids.rename("residuals"))

            # Residual ACF/PACF
            fig3 = plt.figure(figsize=(10, 3))
            plot_acf(resids.dropna(), lags=40, zero=False, ax=fig3.add_subplot(1, 2, 1))
            plot_pacf(resids.dropna(), lags=40, zero=False, ax=fig3.add_subplot(1, 2, 2), method='ywm')
            st.pyplot(fig3)

            # Forecast next N steps
            steps = st.sidebar.number_input("Forecast steps", min_value=1, max_value=200, value=5)
            fc = fitted.get_forecast(steps=steps)
            fc_mean = fc.predicted_mean
            fc_ci = fc.conf_int()

            # Build dataframe for plot
            last_index = series_to_use.index
            if isinstance(last_index, pd.DatetimeIndex):
                future_index = pd.date_range(start=last_index[-1] + pd.Timedelta(days=1), periods=steps, freq='B')
            else:
                # fallback: use integer index
                future_index = np.arange(len(last_index), len(last_index) + steps)

            forecast_df = pd.Series(fc_mean, index=future_index, name='forecast')
            lower = pd.Series(fc_ci.iloc[:, 0], index=future_index)
            upper = pd.Series(fc_ci.iloc[:, 1], index=future_index)

            # Plot history + forecast
            st.subheader("Forecast")
            fig4, ax = plt.subplots(figsize=(10, 5))
            ax.plot(series_to_use.index, series_to_use.values, label="History")
            ax.plot(forecast_df.index, forecast_df.values, label="Forecast", linestyle="--")
            ax.fill_between(forecast_df.index, lower.values, upper.values, color='lightgray', alpha=0.5, label="95% CI")
            ax.set_xlabel("Date"); ax.set_ylabel("Value")
            ax.legend(); ax.grid(alpha=0.3)
            plt.xticks(rotation=45)
            st.pyplot(fig4)

        except Exception as e:
            st.error(f"ARIMA fit failed: {e}")
            st.info("Try changing (p,d,q) or reduce degree / change differencing, or check 'Run KPSS & Prepare Series' first.")

# ---- Footer ----
st.markdown("---")
st.markdown("Notes: KPSS null is stationarity. For regression='ct' null=trend-stationary. For regression='c' null=level-stationary.")
st.markdown("If you want: I can add automatic ARIMA order selection (AIC/BIC-based) or regularization for polynomial detrending.")
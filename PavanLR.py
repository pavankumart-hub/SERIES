# -*- coding: utf-8 -*-
"""STREAMLIT ARIMA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t0sIEeO-RLqBMSOaQfFJyG-R-wNofMO5
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

from statsmodels.tsa.stattools import kpss, adfuller
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.stats.diagnostic import acorr_ljungbox
from scipy.stats import shapiro
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression
import warnings
warnings.filterwarnings("ignore")

# ---------------- Streamlit Config ----------------
st.set_page_config(page_title="Auto ARIMA Forecast", page_icon="üìà", layout="wide")
st.title("üìà Auto ARIMA Forecast for Indian Stocks")

# ---------------- Sidebar Inputs ----------------
st.sidebar.header("Settings")
ticker = st.sidebar.text_input("Enter Indian Stock Ticker (e.g., RELIANCE.NS, TCS.NS, INFY.NS)", "RELIANCE.NS").upper()
price_type = st.sidebar.selectbox("Select Price Type", ["Open", "High", "Low", "Close"])
start_date = st.sidebar.date_input("Select Start Date", datetime(2023, 1, 1))
forecast_steps = st.sidebar.slider("Forecast Steps (days)", 1, 30, 5)

# Run button
run_analysis = st.sidebar.button("üöÄ Run Analysis")

# ---------------- Start when button clicked ----------------
if run_analysis:
    # ‚úÖ 1. Download Data for Indian Stocks
    st.subheader(f"1Ô∏è‚É£ Downloading {price_type} data for {ticker}")
    end_date = datetime.now()

    try:
        # For Indian stocks, use yfinance with .NS suffix
        data = yf.download(ticker, start=start_date, end=end_date, progress=False)
    except Exception as e:
        st.error(f"Error fetching data: {e}")
        st.stop()

    if data.empty:
        st.error("‚ùå No data found for this ticker. Try popular Indian stocks like: RELIANCE.NS, TCS.NS, INFY.NS, HDFCBANK.NS, ICICIBANK.NS")
        st.stop()

    series = data[price_type].dropna()

    # Convert to numeric and handle any non-numeric values
    series = pd.to_numeric(series, errors='coerce').dropna()

    if len(series) == 0:
        st.error("‚ùå No valid numeric data found after cleaning")
        st.stop()

    st.success(f"‚úÖ Downloaded {len(series)} data points for {ticker} from {series.index[0].date()} to {series.index[-1].date()}")

    # Display basic statistics with safe formatting
    current_price = float(series.iloc[-1])
    st.write(f"**Current {price_type} Price:** ‚Çπ{current_price:.2f}")
    st.write(f"**Data Range:** {series.index[0].date()} to {series.index[-1].date()}")
    st.write(f"**Total Trading Days:** {len(series)}")

    # ‚úÖ 2. KPSS Stationarity Test
    st.subheader("2Ô∏è‚É£ Stationarity Test Results")

    def kpss_test(ts):
        try:
            stat, p, lags, crit = kpss(ts, regression="c", nlags="auto")
            return stat, p
        except:
            return None, None

    kpss_stat, kpss_pval = kpss_test(series)

    if kpss_stat is not None:
        st.write(f"**KPSS Test:** Statistic = {kpss_stat:.4f}, p-value = {kpss_pval:.4f}")

        if kpss_pval > 0.05:
            st.success("‚úÖ Series is trend stationary - applying detrending")
            stationary_type = "trend_stationary"
        else:
            st.warning("‚ö†Ô∏è Series is difference stationary - applying differencing")
            stationary_type = "difference_stationary"
    else:
        st.warning("‚ö†Ô∏è KPSS test failed, defaulting to differencing")
        stationary_type = "difference_stationary"

    # ‚úÖ 3. Detrending or Differencing
    st.subheader("3Ô∏è‚É£ Data Preprocessing")

    trend_info = None
    if stationary_type == "trend_stationary":
        st.write("**Detrending using Polynomial Regression**")

        x = np.arange(len(series)).reshape(-1, 1)
        best_deg, best_r2 = 1, -np.inf
        best_lr_model, best_poly = None, None

        # Find best polynomial degree
        for deg in range(1, 4):  # Reduced to 3 for stability
            try:
                poly = PolynomialFeatures(degree=deg)
                X_poly = poly.fit_transform(x)
                model = LinearRegression().fit(X_poly, series)
                r2 = model.score(X_poly, series)
                if r2 > best_r2:
                    best_deg, best_r2 = deg, r2
                    best_lr_model, best_poly = model, poly
            except:
                continue

        if best_lr_model is not None:
            # Calculate trend
            trend = best_lr_model.predict(best_poly.transform(x))
            detrended = series - trend

            st.write(f"**Best Polynomial Degree:** {best_deg} (R¬≤ = {best_r2:.4f})")
            st.write(f"**Trend Values Range:** ‚Çπ{float(trend.min()):.2f} to ‚Çπ{float(trend.max()):.2f}")

            # Store trend info for forecasting
            trend_info = {
                'model': best_lr_model,
                'poly': best_poly,
                'degree': best_deg,
                'r2': best_r2
            }

            # ADF test on detrended series
            try:
                adf_stat, adf_p, _, _, _, _ = adfuller(detrended)
                st.write(f"**ADF Test on Detrended Data:** p-value = {adf_p:.4f}")

                if adf_p < 0.05:
                    st.success("‚úÖ Detrended series is stationary")
                    processed_series = detrended
                    d = 0
                else:
                    st.warning("‚ö†Ô∏è Applying differencing after detrending")
                    processed_series = detrended.diff().dropna()
                    d = 1
            except:
                st.warning("‚ö†Ô∏è ADF test failed, applying differencing")
                processed_series = detrended.diff().dropna()
                d = 1
        else:
            st.warning("‚ö†Ô∏è Detrending failed, applying differencing instead")
            processed_series = series.diff().dropna()
            stationary_type = "difference_stationary"
            d = 1
            trend_info = None

    else:
        st.write("**Applying First-Order Differencing**")
        processed_series = series.diff().dropna()
        st.info("Applied differencing to achieve stationarity")
        d = 1
        trend_info = None

    # Check if we have enough data after processing
    if len(processed_series) < 10:
        st.error("‚ùå Not enough data after preprocessing. Try with a longer date range.")
        st.stop()

    # ‚úÖ 4. ARIMA Model Selection
    st.subheader("4Ô∏è‚É£ ARIMA Model Selection")

    best_aic = np.inf
    best_order = None
    best_arima_model = None

    # Limited grid search for stability
    for p in range(0, 3):  # Reduced range for stability
        for q in range(0, 3):
            try:
                model = ARIMA(processed_series, order=(p, d, q))
                fitted = model.fit()
                if fitted.aic < best_aic:
                    best_aic = fitted.aic
                    best_order = (p, d, q)
                    best_arima_model = fitted
            except:
                continue

    if best_arima_model is None:
        st.error("‚ùå ARIMA fitting failed. Try with different parameters or longer date range.")
        st.stop()

    st.success(f"‚úÖ Best ARIMA Order: {best_order}")
    st.write(f"**Model AIC:** {best_aic:.2f}")

    # ‚úÖ 5. Model Diagnostics
    st.subheader("5Ô∏è‚É£ Model Diagnostics")

    residuals = best_arima_model.resid.dropna()

    if len(residuals) > 3:  # Need at least 3 observations for Shapiro test
        try:
            # Shapiro-Wilk test for normality
            shapiro_stat, shapiro_p = shapiro(residuals)
            st.write(f"**Residual Normality Test (Shapiro-Wilk):** p-value = {shapiro_p:.4f}")
        except:
            st.write("**Residual Normality Test:** Could not compute")
            shapiro_p = 0.0

        try:
            # Ljung-Box test for autocorrelation
            ljung = acorr_ljungbox(residuals, lags=[min(5, len(residuals)-1)], return_df=True)
            lb_p = ljung['lb_pvalue'].iloc[0]
            st.write(f"**Autocorrelation Test (Ljung-Box):** p-value = {lb_p:.4f}")
        except:
            st.write("**Autocorrelation Test:** Could not compute")
            lb_p = 0.0

        if shapiro_p > 0.05 and lb_p > 0.05:
            st.success("‚úÖ Model diagnostics passed - residuals are normal and no autocorrelation")
        else:
            st.warning("‚ö†Ô∏è Some diagnostic tests failed, but proceeding with forecast")
    else:
        st.warning("‚ö†Ô∏è Not enough residuals for diagnostic tests")

    # ‚úÖ 6. Forecasting
    st.subheader("6Ô∏è‚É£ Forecast Results")

    try:
        # Generate forecast
        forecast_result = best_arima_model.get_forecast(steps=forecast_steps)
        forecast_mean_stationary = forecast_result.predicted_mean.values
        conf_int_stationary = forecast_result.conf_int().values

        # Create forecast dates
        last_date = series.index[-1]
        forecast_dates = [last_date + timedelta(days=i) for i in range(1, forecast_steps + 1)]

        # Convert to original scale
        if stationary_type == "trend_stationary" and trend_info is not None:
            # Add back trend component
            future_x = np.arange(len(series), len(series) + len(forecast_mean_stationary)).reshape(-1, 1)
            trend_future = trend_info['model'].predict(trend_info['poly'].transform(future_x))

            forecast_mean_original = forecast_mean_stationary + trend_future
            conf_int_original = conf_int_stationary + trend_future.reshape(-1, 1)

            # Display trend information
            st.write("---")
            st.subheader("üìä Trend Analysis")
            st.write(f"**Trend Component Used:** Polynomial Degree {trend_info['degree']}")
            st.write(f"**Trend Fit Quality (R¬≤):** {trend_info['r2']:.4f}")
            st.write(f"**Future Trend Values:**")
            for i, (date, trend_val) in enumerate(zip(forecast_dates, trend_future)):
                st.write(f"  {date.strftime('%Y-%m-%d')}: ‚Çπ{float(trend_val):.2f}")

        else:
            # For differenced series
            forecast_mean_original = np.cumsum(forecast_mean_stationary) + current_price
            conf_int_original = conf_int_stationary + current_price

        # Display forecast results
        st.write("---")
        st.subheader("üéØ Price Forecast")

        forecast_data = []
        for i, (date, pred, lower, upper) in enumerate(zip(forecast_dates, forecast_mean_original,
                                                          conf_int_original[:, 0], conf_int_original[:, 1])):
            forecast_data.append({
                "Day": i + 1,
                "Date": date.strftime("%Y-%m-%d"),
                f"Forecast (‚Çπ)": f"{float(pred):.2f}",
                "Lower CI (‚Çπ)": f"{float(lower):.2f}",
                "Upper CI (‚Çπ)": f"{float(upper):.2f}",
                "Range (‚Çπ)": f"¬±{float((upper - lower)/2):.2f}"
            })

        # Display as a nice table
        forecast_df = pd.DataFrame(forecast_data)
        st.table(forecast_df)

        # Summary statistics
        st.write("---")
        st.subheader("üìà Forecast Summary")
        avg_forecast = float(np.mean(forecast_mean_original))
        price_change = avg_forecast - current_price
        percent_change = (price_change / current_price) * 100

        st.write(f"**Current {price_type} Price:** ‚Çπ{current_price:.2f}")
        st.write(f"**Average Forecasted Price:** ‚Çπ{avg_forecast:.2f}")
        st.write(f"**Expected Change:** ‚Çπ{price_change:+.2f} ({percent_change:+.2f}%)")

        if percent_change > 1:
            st.success(f"üìà Bullish Outlook: Expected increase of {percent_change:.2f}%")
        elif percent_change < -1:
            st.error(f"üìâ Bearish Outlook: Expected decrease of {abs(percent_change):.2f}%")
        else:
            st.info(f"‚û°Ô∏è Neutral Outlook: Minimal change expected ({percent_change:+.2f}%)")

    except Exception as e:
        st.error(f"‚ùå Forecasting error: {str(e)}")
        st.info("Try with fewer forecast steps or a different stock")

    # ‚úÖ 7. Popular Indian Stock Suggestions
    st.write("---")
    st.subheader("üí° Popular Indian Stock Tickers")
    indian_stocks = {
        "RELIANCE.NS": "Reliance Industries",
        "TCS.NS": "Tata Consultancy Services",
        "INFY.NS": "Infosys",
        "HDFCBANK.NS": "HDFC Bank",
        "ICICIBANK.NS": "ICICI Bank",
        "HINDUNILVR.NS": "Hindustan Unilever",
        "ITC.NS": "ITC Limited",
        "SBIN.NS": "State Bank of India",
        "BHARTIARTL.NS": "Bharti Airtel"
    }

    for ticker_code, company_name in indian_stocks.items():
        st.write(f"`{ticker_code}` - {company_name}")

else:
    st.info("üëà Enter Indian stock ticker (e.g., RELIANCE.NS) and click **Run Analysis** to begin.")
    st.write("**üí° Tip:** For Indian stocks, always add `.NS` suffix to the ticker symbol")

st.markdown("---")
st.markdown("Built with ‚ù§Ô∏è for Indian Stock Market Analysis | ARIMA Forecasting")
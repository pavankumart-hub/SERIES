# -*- coding: utf-8 -*-
"""STREAMLIT LSTM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eoN80OO2qR9Eyhovyf9Kc39c7xjxeHiS
"""

# streamlit_app.py
import streamlit as st
import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from statsmodels.tsa.seasonal import STL
from sklearn.metrics import mean_squared_error

# --------------------------
# Sidebar - User Inputs
# --------------------------
st.title("ðŸ“ˆ HDFCBANK High Price Forecast using LSTM + STL")

ticker = st.text_input("Enter Ticker Symbol:", "HDFCBANK.NS")
start_date = st.date_input("Start Date:", pd.to_datetime("2020-01-01"))
end_date_forecast = st.date_input("End Date:", pd.to_datetime(datetime.today().strftime('%Y-%m-%d')))
window_size = st.slider("LSTM Window Size:", min_value=5, max_value=30, value=10)
epochs = st.slider("Training Epochs:", min_value=5, max_value=50, value=10)

st.write(f"ðŸ“… Forecasting data from {start_date} to {end_date_forecast}")

# --------------------------
# Download Data
# --------------------------
@st.cache_data
def load_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date)
    return data

data = load_data(ticker, start_date, end_date_forecast)
d_high = data["High"]

st.write(f"ðŸ“Š Showing last 5 high prices for {ticker}")
st.dataframe(d_high.tail(5))

# --------------------------
# STL Decomposition
# --------------------------
stl = STL(d_high, period=30)
result = stl.fit()
trend = result.trend
seasonal = result.seasonal

# --------------------------
# Prepare LSTM Data
# --------------------------
def prepare_lstm_data(series, window_size):
    scaler = MinMaxScaler()
    scaled = scaler.fit_transform(series.values.reshape(-1, 1))
    X, y = [], []
    for i in range(len(scaled) - window_size):
        X.append(scaled[i:i+window_size])
        y.append(scaled[i+window_size])
    return np.array(X), np.array(y), scaler

X_trend, y_trend, scaler_trend = prepare_lstm_data(trend, window_size)
X_seasonal, y_seasonal, scaler_seasonal = prepare_lstm_data(seasonal, window_size)

# --------------------------
# Build & Train LSTM
# --------------------------
def build_and_train_lstm(X, y, epochs):
    model = Sequential([
        LSTM(50, return_sequences=True, input_shape=(X.shape[1], 1)),
        LSTM(50, return_sequences=True),
        LSTM(50, return_sequences=True),
        LSTM(50, return_sequences=False),
        Dense(1)
    ])
    model.compile(optimizer='adam', loss='mse')
    model.fit(X, y, epochs=epochs, batch_size=10, verbose=0)
    return model

with st.spinner("Training LSTM models..."):
    model_trend = build_and_train_lstm(X_trend, y_trend, epochs)
    model_seasonal = build_and_train_lstm(X_seasonal, y_seasonal, epochs)

# --------------------------
# Predictions & Reconstruction
# --------------------------
y_trend_pred = model_trend.predict(X_trend)
y_seasonal_pred = model_seasonal.predict(X_seasonal)

trend_pred = scaler_trend.inverse_transform(y_trend_pred)
seasonal_pred = scaler_seasonal.inverse_transform(y_seasonal_pred)
final_pred = trend_pred.flatten() + seasonal_pred.flatten()
actual = d_high.values[window_size:]

rmse = np.sqrt(mean_squared_error(actual, final_pred))
st.write(f"ðŸ“‰ RMSE (Reconstructed): {rmse:.4f}")

# Plot Actual vs Predicted
fig, ax = plt.subplots(figsize=(10, 5))
ax.plot(actual, label="Actual")
ax.plot(final_pred, label="Predicted (Trend + Seasonal)")
ax.set_title("LSTM Forecast on STL Components")
ax.legend()
ax.grid(True)
st.pyplot(fig)

# --------------------------
# Next Day Forecast
# --------------------------
last_trend_window = trend.values[-window_size:].reshape(1, window_size, 1)
last_trend_scaled = scaler_trend.transform(last_trend_window.reshape(window_size, 1)).reshape(1, window_size, 1)
next_trend_scaled = model_trend.predict(last_trend_scaled)
next_trend = scaler_trend.inverse_transform(next_trend_scaled)[0][0]

last_seasonal_window = seasonal.values[-window_size:].reshape(1, window_size, 1)
last_seasonal_scaled = scaler_seasonal.transform(last_seasonal_window.reshape(window_size, 1)).reshape(1, window_size, 1)
next_seasonal_scaled = model_seasonal.predict(last_seasonal_scaled)
next_seasonal = scaler_seasonal.inverse_transform(next_seasonal_scaled)[0][0]

next_day_forecast_high_LSTM = next_trend + next_seasonal
st.success(f"ðŸ“… Forecast for Next Day (Trend + Seasonal): {next_day_forecast_high_LSTM:.4f}")